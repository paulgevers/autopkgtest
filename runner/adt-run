#!/usr/bin/python3 -u
#
# adt-run is part of autopkgtest
# autopkgtest is a tool for testing Debian binary packages
#
# autopkgtest is Copyright (C) 2006-2015 Canonical Ltd.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# See the file CREDITS for a full list of credits information (often
# installed as /usr/share/doc/autopkgtest/CREDITS).

import signal
import tempfile
import sys
import subprocess
import traceback
import re
import os
import errno
import shutil
import atexit

from debian import deb822

try:
    our_base = os.environ['AUTOPKGTEST_BASE'] + '/lib'
except KeyError:
    our_base = '/usr/share/autopkgtest/python'
sys.path.insert(1, our_base)
import adtlog
import testdesc
import adt_run_args
import adt_testbed

# ---------- global variables

tmp = None		# pathstring on host
testbed = None		# Testbed
opts = None             # argparse options
actions = None          # list of (action_type, path)
errorcode = 0		# exit status that we are going to use
binaries = None		# Binaries (.debs we have registered)


# ---------- convenience functions

def bomb(m):
    raise adtlog.AutopkgtestError(m)


def badpkg(m):
    raise adtlog.BadPackageError(m)


def files_from_dsc(dsc_path):
    '''Get files from a .dsc or a .changes

    Return list of files, including the directory of dsc_path.
    '''
    try:
        files = testdesc.parse_rfc822(dsc_path).__next__()['Files'].split()
    except (StopIteration, KeyError):
        badpkg('%s is invalid and does not contain Files:' % dsc_path)

    dsc_dir = os.path.dirname(dsc_path)

    return [os.path.join(dsc_dir, f) for f in files if '.' in f and '_' in f]


def setup_trace():
    global tmp

    if opts.output_dir is not None:
        os.makedirs(opts.output_dir, exist_ok=True)
        if os.listdir(opts.output_dir):
            bomb('--output-dir "%s" is not empty' % opts.output_dir)
        tmp = opts.output_dir
    else:
        assert(tmp is None)
        tmp = tempfile.mkdtemp(prefix='adt-run.output.')
        os.chmod(tmp, 0o755)

    if opts.logfile is None and opts.output_dir is not None:
        opts.logfile = opts.output_dir + '/log'

    if opts.logfile is not None:
        # tee stdout/err into log file
        (fd, fifo_log) = tempfile.mkstemp(prefix='adt-fifo-log.')
        os.close(fd)
        os.unlink(fifo_log)
        os.mkfifo(fifo_log)
        atexit.register(os.unlink, fifo_log)
        out_tee = subprocess.Popen(['tee', fifo_log],
                                   stdin=subprocess.PIPE)
        err_tee = subprocess.Popen(['tee', fifo_log, '-a', '/dev/stderr'],
                                   stdin=subprocess.PIPE,
                                   stdout=open('/dev/null', 'wb'))
        log_cat = subprocess.Popen(['cat', fifo_log], stdout=open(opts.logfile, 'wb'))
        adtlog.enable_colors = False
        os.dup2(out_tee.stdin.fileno(), sys.stdout.fileno())
        os.dup2(err_tee.stdin.fileno(), sys.stderr.fileno())

        def cleanup():
            os.close(sys.stdout.fileno())
            os.close(out_tee.stdin.fileno())
            out_tee.wait()
            os.close(sys.stderr.fileno())
            os.close(err_tee.stdin.fileno())
            err_tee.wait()
            log_cat.wait()

        atexit.register(cleanup)

    if opts.summary is not None:
        adtlog.summary_stream = open(opts.summary, 'w+b', 0)
    else:
        adtlog.summary_stream = open(os.path.join(tmp, 'summary'), 'w+b', 0)


def run_tests(tests, tree):
    global errorcode, testbed

    if not tests:
        # if we have skipped tests, don't claim that we don't have any
        if not errorcode & 2:
            adtlog.report('*', 'SKIP no tests in this package')
            errorcode |= 8
        return

    for t in tests:
        # Set up clean test bed with given dependencies
        adtlog.info('test %s: preparing testbed' % t.name)
        testbed.reset(t.depends, 'needs-recommends' in t.restrictions)
        binaries.publish()
        testbed.install_deps(t.depends, 'needs-recommends' in t.restrictions)

        testbed.run_test(tree, t, opts.env, opts.shell_fail, opts.shell)
        if not t.result:
            errorcode |= 4
        if 'breaks-testbed' in t.restrictions:
            testbed.needs_reset()

    testbed.needs_reset()


def print_exception(ei, msgprefix=''):
    if msgprefix:
        adtlog.error(msgprefix)
    (et, e, tb) = ei
    if et is adtlog.BadPackageError:
        adtlog.preport('blame: ' + ' '.join(testbed.blamed))
        adtlog.preport('badpkg: ' + e.args[0])
        adtlog.error('erroneous package: ' + e.args[0])
        adtlog.psummary('erroneous package: ' + e.args[0])
        return 12
    elif et is adtlog.TestbedFailure:
        adtlog.error('testbed failure: ' + e.args[0])
        adtlog.psummary('testbed failure: ' + e.args[0])
        return 16
    elif et is adtlog.AutopkgtestError:
        adtlog.psummary(e.args[0])
        adtlog.error(e.args[0])
        return 20
    else:
        adtlog.error('unexpected error:')
        adtlog.psummary('quitting: unexpected error, see log')
        traceback.print_exc(None, sys.stderr)
        return 20


def cleanup():
    try:
        if testbed is not None:
            testbed.reset_apt()
            testbed.stop()
        if opts.output_dir is None and tmp is not None:
            shutil.rmtree(tmp, ignore_errors=True)
    except:
        print_exception(sys.exc_info(),
                        '\nadt-run: error cleaning up:\n')
        sys.exit(20)


def signal_handler(signum, frame):
    adtlog.error('Received signal %i, cleaning up...' % signum)
    signal.signal(signum, signal.SIG_DFL)
    try:
        # don't call cleanup() here, resetting apt takes too long
        if testbed:
            testbed.stop()
    finally:
        os.kill(os.getpid(), signum)


# ---------- registration, installation etc. of .deb's: Binaries


class Binaries:

    def __init__(self, tb):
        # the binary dir must exist across tb reopenings, so don't use a
        # adt_testbed.TempPath
        self.dir = adt_testbed.Path(
            tb, os.path.join(tmp, 'binaries'),
            os.path.join(tb.scratch, 'binaries'), is_dir=True)
        os.mkdir(self.dir.host)
        # clean up an empty binaries output dir
        atexit.register(lambda: os.path.exists(self.dir.host) and (
            os.listdir(self.dir.host) or os.rmdir(self.dir.host)))

        adtlog.debug('Binaries: initialising')
        self.apt_get_cmd = ['apt-get', '--quiet',
                            '-o', 'Debug::pkgProblemResolver=true',
                            '-o', 'APT::Get::force-yes=true',
                            '-o', 'APT::Get::Assume-Yes=true']

    def _configure_apt(self, tb):
        prefs = adt_testbed.Path(testbed, os.path.join(tmp, 'apt-prefs'),
                                 '/etc/apt/preferences.d/90autopkgtest')
        with open(prefs.host, 'w') as f:
            f.write('''Package: *
Pin: origin ""
Pin-Priority: 1002
''')
        prefs.copydown()
        os.unlink(prefs.host)

    def reset(self):
        adtlog.debug('Binaries: reset')
        shutil.rmtree(self.dir.host)
        os.mkdir(self.dir.host)
        self.blamed = []
        self.registered = set()

    def register(self, path, pkgname):
        adtlog.debug('Binaries: register deb=%s pkgname=%s ' % (path, pkgname))
        self.blamed += testbed.blamed

        dest = os.path.join(self.dir.host, pkgname + '.deb')

        # link or copy to self.dir
        try:
            os.remove(dest)
        except (IOError, OSError) as oe:
            if oe.errno != errno.ENOENT:
                raise oe
        try:
            os.link(path, dest)
        except (IOError, OSError) as oe:
            if oe.errno != errno.EXDEV:
                raise oe
            shutil.copy(path, dest)
        # clean up locally built debs (what=ubtreeN) to keep a clean
        # --output-dir, but don't clean up --binary arguments
        if opts.output_dir and path.startswith(opts.output_dir):
            atexit.register(lambda f: os.path.exists(f) and os.unlink(f), path)
        self.registered.add(pkgname)

    def publish(self):
        adtlog.debug('Binaries: publish')
        if not self.registered:
            adtlog.debug('Binaries: no registered binaries, not publishing anything')
            return

        self._configure_apt(testbed)

        try:
            with open(os.path.join(self.dir.host, 'Packages'), 'w') as f:
                subprocess.check_call(['apt-ftparchive', 'packages', '.'],
                                      cwd=self.dir.host, stdout=f)
            with open(os.path.join(self.dir.host, 'Release'), 'w') as f:
                subprocess.call(['apt-ftparchive', 'release', '.'],
                                cwd=self.dir.host, stdout=f)
        except subprocess.CalledProcessError as e:
            bomb('apt-ftparchive failed: %s' % e)

        # copy binaries directory to testbed; self.dir.tb might have changed
        # since last time due to a reset, so update it
        self.dir.tb = os.path.join(testbed.scratch, 'binaries')
        testbed.check_exec(['rm', '-rf', self.dir.tb])
        self.dir.copydown()

        aptupdate_out = adt_testbed.TempPath(testbed, 'apt-update.out')
        script = '''
  echo "deb [trusted=yes] file://%(d)s /" >/etc/apt/sources.list.d/autopkgtest.list
  if [ "x`ls /var/lib/dpkg/updates`" != x ]; then
    echo >&2 "/var/lib/dpkg/updates contains some files, aargh"; exit 1
  fi
  apt-get --quiet --no-list-cleanup -o Dir::Etc::sourcelist=/etc/apt/sources.list.d/autopkgtest.list -o Dir::Etc::sourceparts=/dev/null update 2>&1
  cp /var/lib/dpkg/status %(o)s
  ''' % {'d': self.dir.tb, 'o': aptupdate_out.tb}
        testbed.mungeing_apt()
        testbed.check_exec(['sh', '-ec', script], kind='install')
        testbed.blamed += self.blamed

        aptupdate_out.copyup()

        adtlog.debug('Binaries: publish reinstall checking...')
        pkgs_reinstall = set()
        pkg = None
        for l in open(aptupdate_out.host, encoding='UTF-8'):
            if l.startswith('Package: '):
                pkg = l[9:].rstrip()
            elif l.startswith('Status: install '):
                if pkg in self.registered:
                    pkgs_reinstall.add(pkg)
                    adtlog.debug('Binaries: publish reinstall needs ' + pkg)

        if pkgs_reinstall:
            for pkg in pkgs_reinstall:
                testbed.blame(pkg)
            rc = testbed.execute(
                self.apt_get_cmd + ['--reinstall', 'install'] + list(pkgs_reinstall),
                kind='install')[0]
            if rc:
                badpkg('installation of basic binaries failed, exit code %d' % rc)

        adtlog.debug('Binaries: publish done')

# ---------- processing of sources (building)


def deb_package_name(deb):
    '''Return package name from a .deb'''

    try:
        output = subprocess.check_output(['dpkg-deb', '--info', '--', deb, 'control'])
    except subprocess.CalledProcessError as e:
        badpkg('failed to parse binary package: %s' % e)
    pkg_re = re.compile(b'^\s*Package\s*:\s*([0-9a-z][-+.0-9a-z]*)\s*$')
    result = None
    for l in output.split(b'\n'):
        m = pkg_re.match(l)
        if not m:
            continue
        if result:
            badpkg('two Package: lines in control file')
        result = m.groups()[0].decode('ASCII')
    if not result:
        badpkg('no good Package: line in control file')
    return result


def source_rules_command(script, which, cwd=None, results_lines=0):
    if cwd is None:
        cwd = '.'

    # there's no way to tell su to not reset $PATH, for install-tmp mode
    if testbed.install_tmp_env:
        for e in testbed.install_tmp_env:
            if e.startswith('PATH='):
                script = ['export ' + e] + script
                break

    if adtlog.verbosity > 1:
        script = ['exec 3>&1 >&2', 'set -x', 'cd ' + cwd] + script
    else:
        script = ['exec 3>&1 >&2', 'cd ' + cwd] + script
    script = '; '.join(script)

    # run command as user, if available
    if testbed.user and 'root-on-testbed' in testbed.caps:
        script = "su --shell=/bin/sh %s -c 'set -e; %s'" % (testbed.user, script)

    (rc, out, _) = testbed.execute(['sh', '-ec', script],
                                   stdout=subprocess.PIPE,
                                   kind='build')
    results = out.rstrip('\n').splitlines()
    if rc:
        if opts.shell_fail:
            testbed.run_shell()
        badpkg('rules %s failed with exit code %d' % (which, rc))
    if results_lines is not None and len(results) != results_lines:
        badpkg('got %d lines of results from %s where %d expected'
               % (len(results), which, results_lines))
    if results_lines == 1:
        return results[0]
    return results


def build_source(kind, arg, built_binaries):
    '''Prepare action argument for testing

    This builds packages when necessary and registers their binaries, copies
    tests into the testbed, etc.

    Return a adt_testbed.Path to the unpacked tests tree.
    '''
    testbed.blame(arg)
    testbed.reset([], testbed.recommends_installed)

    def debug_b(m):
        adtlog.debug('build_source: <%s:%s> %s' % (kind, arg, m))

    # copy necessary source files into testbed and set create_command for final unpacking
    if kind == 'source':
        dsc = arg
        dsc_tb = os.path.join(testbed.scratch, os.path.basename(dsc))

        # copy .dsc file itself
        adt_testbed.Path(testbed, dsc, dsc_tb).copydown()
        # copy files from it
        for part in files_from_dsc(dsc):
            p = adt_testbed.Path(testbed, part, os.path.join(testbed.scratch, os.path.basename(part)))
            p.copydown()

        create_command = 'dpkg-source -x "%s"' % dsc_tb

    elif kind == 'unbuilt-tree':
        dsc = os.path.join(tmp, 'fake.dsc')
        with open(dsc, 'w', encoding='UTF-8') as f_dsc:
            with open(os.path.join(arg, 'debian/control'), encoding='UTF-8') as f_control:
                for l in f_control:
                    if l == '\n':
                        break
                    f_dsc.write(l)
            f_dsc.write('Binary: none-so-this-is-not-a-package-name\n')
        atexit.register(lambda f: os.path.exists(f) and os.unlink(f), dsc)

        # copy unbuilt tree into testbed
        ubtree = adt_testbed.Path(testbed, arg,
                                  os.path.join(testbed.scratch, 'ubtree-' + os.path.basename(arg)))
        ubtree.copydown()
        create_command = 'cp -rd --preserve=timestamps -- "%s" real-tree' % ubtree.tb

    elif kind == 'built-tree':
        # this is a special case: we don't want to build, or even copy down
        # (and back up) the tree here for efficiency; so shortcut everything
        # below and just set the tests_tree and get the package version
        tests_tree = adt_testbed.Path(testbed, arg, os.path.join(testbed.scratch, 'tree'), is_dir=True)

        changelog = os.path.join(arg, 'debian', 'changelog')
        if os.path.exists(changelog):
            with open(changelog, encoding='UTF-8') as f:
                (testpkg_name, testpkg_version, _) = f.readline().split(' ', 2)
                testpkg_version = testpkg_version[1:-1]  # chop off parentheses

            adtlog.info('testing package %s version %s' % (testpkg_name, testpkg_version))
            if opts.output_dir:
                with open(os.path.join(tmp, 'testpkg-version'), 'w') as f:
                    f.write('%s %s\n' % (testpkg_name, testpkg_version))
        return tests_tree

    elif kind == 'apt-source':
        # apt-get source is terribly noisy; only show what gets downloaded
        create_command = 'OUT=$(apt-get source -q --only-source %s); echo "$OUT" | grep ^Get: || true' % arg

    else:
        bomb('unknown action kind for build_source: ' + kind)

    if kind in ['source', 'apt-source']:
        testbed.install_deps([], False)
        if testbed.execute(['which', 'dpkg-source'],
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)[0] != 0:
            adtlog.debug('dpkg-source not available in testbed, installing dpkg-dev')
            # Install dpkg-source for unpacking .dsc
            testbed.satisfy_dependencies_string('dpkg-dev',
                                                'install dpkg-dev')

    # run create_command
    script = [
        'builddir=$(mktemp -d %s/build.XXX)' % testbed.scratch,
        'cd $builddir',
        create_command,
        'chmod -R a+rX .',
        'cd [a-z0-9]*/.',
        'pwd >&3',
        'sed -n "1 {s/).*//; s/ (/\\n/; p}" debian/changelog >&3',
        'set +e; grep -q "^Restrictions:.*\\bbuild-needed\\b" debian/tests/control 2>/dev/null; echo $? >&3'
    ]

    (result_pwd, testpkg_name, testpkg_version, build_needed_rc) = \
        source_rules_command(script, 'extract', results_lines=4)

    # record tested package version
    adtlog.info('testing package %s version %s' % (testpkg_name, testpkg_version))
    if opts.output_dir:
        with open(os.path.join(tmp, 'testpkg-version'), 'w') as f:
            f.write('%s %s\n' % (testpkg_name, testpkg_version))

    # For optional builds:
    #
    # We might need to build the package because:
    #   - we want its binaries
    #   - the test control file says so (assuming we have any tests)

    build_needed = False
    if built_binaries:
        adtlog.info('build needed for binaries')
        build_needed = True
    elif build_needed_rc == '0':
        adtlog.info('build needed for tests')
        build_needed = True
    else:
        adtlog.info('build not needed')

    if build_needed:
        testbed.needs_reset()
        if kind not in ['dsc', 'apt-source']:
            testbed.install_deps([], False)

        if kind == 'apt-source':
            # we need to get the downloaded debian/control from the testbed, so
            # that we can avoid calling "apt-get build-dep" and thus
            # introducing a second mechanism for installing build deps
            pkg_control = adt_testbed.Path(testbed,
                                           os.path.join(tmp, 'apt-control'),
                                           os.path.join(result_pwd, 'debian/control'), False)
            pkg_control.copyup()
            dsc = pkg_control.host

        with open(dsc, encoding='UTF-8') as f:
            d = deb822.Deb822(sequence=f)
            bd = d.get('Build-Depends', '')
            bdi = d.get('Build-Depends-Indep', '')

        # determine build command and build-essential packages
        build_essential = ['build-essential']
        dpkg_buildpackage = 'dpkg-buildpackage -us -uc -b'
        if opts.gainroot:
            dpkg_buildpackage += ' -r' + opts.gainroot
        else:
            if testbed.user or 'root-on-testbed' not in testbed.caps:
                build_essential += ['fakeroot']

        testbed.satisfy_dependencies_string(bd + ', ' + bdi + ', ' + ', '.join(build_essential), arg,
                                            build_dep=True, shell_on_failure=opts.shell_fail)

        source_rules_command([dpkg_buildpackage], 'build', cwd=result_pwd)

    # copy built tree from testbed to hosts
    tests_tree = adt_testbed.Path(testbed, os.path.join(tmp, 'tests-tree'), result_pwd, is_dir=True)
    atexit.register(shutil.rmtree, tests_tree.host, ignore_errors=True)
    tests_tree.copyup()

    if not build_needed:
        return tests_tree

    if built_binaries:
        debug_b('want built binaries, getting and registering built debs')
        result_debs = testbed.check_exec(['sh', '-ec', 'cd "%s"; echo *.deb' %
                                          os.path.dirname(result_pwd)], stdout=True).strip()
        if result_debs == '*.deb':
            debs = []
        else:
            debs = result_debs.split()
        debug_b('debs=' + repr(debs))

        # determine built debs and copy them from testbed
        deb_re = re.compile('^([-+.0-9a-z]+)_[^_/]+(?:_[^_/]+)\.deb$')
        for deb in debs:
            m = deb_re.match(deb)
            if not m:
                badpkg("badly-named binary `%s'" % deb)
            pkgname = m.groups()[0]
            debug_b(' deb=%s, pkgname=%s' % (deb, pkgname))
            deb_path = adt_testbed.Path(testbed,
                                        os.path.join(tmp, os.path.basename(deb)),
                                        os.path.join(result_pwd, '..', deb),
                                        False)
            deb_path.copyup()
            binaries.register(deb_path.host, pkgname)
        debug_b('got all built binaries')

    return tests_tree


def process_actions():
    global actions, binaries, errorcode

    binaries = Binaries(testbed)
    binaries.reset()
    control_override = None
    testname = None
    pending_click_source = None

    for (kind, arg, built_binaries) in actions:
        # non-tests/build actions
        if kind == 'override-control':
            control_override = arg
            if not os.access(control_override, os.R_OK):
                bomb('cannot read ' + control_override)
            continue
        if kind == 'testname':
            testname = arg
            continue
        if kind == 'binary':
            testbed.blame('arg:' + arg)
            pkg = deb_package_name(arg)
            testbed.blame('deb:' + pkg)
            binaries.register(arg, pkg)
            continue
        if kind == 'click-source':
            if pending_click_source:
                adtlog.warning('Ignoring --click-source %s, no subsequent --click argument' % pending_click_source)
            pending_click_source = arg
            continue

        # tests/build actions
        assert kind in ('source', 'unbuilt-tree', 'built-tree', 'apt-source', 'click')
        adtlog.info('@@@@@@@@@@@@@@@@@@@@ %s %s' % (kind, arg))

        if kind == 'click':
            if control_override:
                # locally specified manifest
                with open(control_override) as f:
                    manifest = f.read()
                clicks = []
                use_installed = False
                if os.path.exists(arg):
                    clicks.append(arg)
                    use_installed = True
                (srcdir, tests, skipped) = testdesc.parse_click_manifest(
                    manifest, testbed.caps, clicks, use_installed, pending_click_source)

            elif os.path.exists(arg):
                # local .click package file
                (srcdir, tests, skipped) = testdesc.parse_click(
                    arg, testbed.caps, srcdir=pending_click_source)
            else:
                # already installed click package name
                if testbed.user:
                    u = ['--user', testbed.user]
                else:
                    u = []
                manifest = testbed.check_exec(['click', 'info'] + u + [arg], stdout=True)
                (srcdir, tests, skipped) = testdesc.parse_click_manifest(
                    manifest, testbed.caps, [], True, pending_click_source)

            if not srcdir:
                bomb('No click source available for %s' % arg)

            tests_tree = adt_testbed.Path(
                testbed, srcdir, os.path.join(testbed.scratch, 'tree'),
                is_dir=True)
            pending_click_source = None
        else:
            tests_tree = build_source(kind, arg, built_binaries)
            try:
                (tests, skipped) = testdesc.parse_debian_source(
                    tests_tree.host, testbed.caps, testbed.dpkg_arch,
                    control_path=control_override,
                    auto_control=opts.auto_control)
            except testdesc.InvalidControl as e:
                badpkg(str(e))

        if skipped:
            errorcode |= 2

        if testname:
            adtlog.debug('filtering testname %s for package %s %s' %
                         (testname, kind, arg))
            tests = [t for t in tests if t.name == testname]
            if not tests:
                adtlog.error('%s %s has no test matching --testname %s' %
                             (kind, arg, testname))
                # error code will be set later
            testname = None

        control_override = None
        run_tests(tests, tests_tree)

        adtlog.summary_stream.flush()
        if adtlog.verbosity >= 1:
            adtlog.summary_stream.seek(0)
            adtlog.info('@@@@@@@@@@@@@@@@@@@@ summary')
            sys.stderr.buffer.write(adtlog.summary_stream.read())
        adtlog.summary_stream.close()


def main():
    global testbed, opts, actions
    try:
        (opts, actions, vserver_args) = adt_run_args.parse_args()
    except SystemExit:
        # argparser exits with error 2 by default, but we have a different
        # meaning for that already
        sys.exit(20)

    # vserver can be given without "adt-virt-" prefix
    if '/' not in vserver_args[0] and not vserver_args[0].startswith('adt-virt-'):
        vserver_args[0] = 'adt-virt-' + vserver_args[0]

    # ensure proper cleanup on signals
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGQUIT, signal_handler)

    try:
        setup_trace()
        testbed = adt_testbed.Testbed(vserver_argv=vserver_args,
                                      output_dir=tmp,
                                      user=opts.user,
                                      setup_commands=opts.setup_commands,
                                      add_apt_pockets=opts.apt_pocket,
                                      copy_files=opts.copy)
        testbed.start()
        testbed.open()
        process_actions()
    except:
        ec = print_exception(sys.exc_info(), '')
        cleanup()
        sys.exit(ec)
    cleanup()
    sys.exit(errorcode)

main()
